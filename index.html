<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Avoid LTN</title>
  <style>
    :root {
      --sky-top: #6ec6ff;
      --sky-mid: #a6ddff;
      --sky-bot: #e9f7ff;
      --accent: #ff3b3b;
      --hud: rgba(0,0,0,0.45);
      --hud-text: #ffffff;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: linear-gradient(180deg, var(--sky-top) 0%, var(--sky-mid) 60%, var(--sky-bot) 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: #14323f;
    }
    #game {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none; /* allow custom touch handling */
    }
    .hud {
      position: fixed;
      top: env(safe-area-inset-top, 0);
      left: env(safe-area-inset-left, 0);
      right: env(safe-area-inset-right, 0);
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      pointer-events: none; /* clicks pass through */
    }
    .hud .panel {
      pointer-events: auto; /* but controls inside should work */
      background: var(--hud);
      border-radius: 12px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      color: var(--hud-text);
      padding: 8px 12px;
      display: inline-flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    }
    .hud .stat {
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.3px;
    }
    .hud .controls label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      opacity: 0.95;
    }
    .hud input[type="file"] {
      color: #fff;
      font-size: 12px;
      max-width: 52vw;
    }
    .overlay {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 500px at 50% 20%, rgba(255,255,255,0.7), rgba(200,230,255,0.75), rgba(160,210,255,0.9));
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      z-index: 4;
    }
    .card {
      width: min(92vw, 720px);
      background: #ffffffee;
      border-radius: 16px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.15);
      padding: 22px 22px 18px;
      border: 1px solid rgba(10,80,120,0.1);
    }
    .card h1 { margin: 0 0 6px; font-size: clamp(22px, 4.5vw, 32px); }
    .card p { margin: 6px 0; line-height: 1.4; }
    .card .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-top: 10px; }
    .btn {
      appearance: none;
      border: none;
      background: var(--accent);
      color: white;
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 700;
      letter-spacing: 0.3px;
      box-shadow: 0 8px 18px rgba(255,59,59,0.35);
      cursor: pointer;
      transition: transform .06s ease;
    }
    .btn:active { transform: translateY(1px) scale(0.99); }
    .icon-btn {
      appearance: none;
      width: 36px;
      height: 36px;
      background: transparent;
      border: none;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      padding: 0;
      box-shadow: none;
      color: #fff;
    }
    .icon-btn:hover { background: rgba(255,255,255,0.08); }
    .icon-btn:active { transform: translateY(1px) scale(0.98); }
    .muted { opacity: 0.8; font-size: 13px; }
    .legend { font-size: 13px; opacity: 0.9; }
    .hidden { display: none !important; }
    /* Game over card tweaks */
    #gameover .card.gameover-card {
      width: min(80vw, 320px);
      border-radius: 0;
      padding: 16px;
      display: grid;
      gap: 12px;
      justify-items: center;
      text-align: center;
    }
    #gameover .score {
      font-size: clamp(28px, 6vw, 44px);
      font-weight: 800;
      color: #14323f;
      margin: 4px 0 8px;
    }
    .btn.big {
      width: 100%;
      padding: 14px 18px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="panel">
      <div class="stat" id="altitude">word: 0 m</div>
    </div>
    <div class="panel controls">
      <!-- Set photos once (persisted) -->
      <button class="icon-btn" id="setBalloonBtn" title="Set balloon photo" aria-label="Set balloon photo">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" aria-hidden="true">
          <path d="M4 7h3l2-3h6l2 3h3a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2z" />
          <circle cx="12" cy="13" r="3" />
        </svg>
      </button>
      <button class="icon-btn" id="setMinesBtn" title="Set mine photos" aria-label="Set mine photos">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" aria-hidden="true">
          <rect x="3" y="5" width="18" height="14" rx="2" ry="2" />
          <path d="M8 11l2 2 4-4" />
        </svg>
      </button>
      <input type="file" id="balloonInput" accept="image/*" style="display:none" />
      <input type="file" id="minesInput" accept="image/*" style="display:none" />
      <button class="icon-btn" id="restartBtn" title="Restart" aria-label="Restart">
        <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="22" height="22" aria-hidden="true">
          <path d="M3 12a9 9 0 1 1 3 6.7" />
          <polyline points="3 3 3 9 9 9" />
        </svg>
      </button>
      <button class="icon-btn" id="soundBtn" title="Sound: Off" aria-label="Sound">
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M3 9v6h4l5 4V5L7 9H3z"></path>
          <line x1="19" y1="9" x2="23" y2="13"></line>
          <line x1="23" y1="9" x2="19" y2="13"></line>
        </svg>
      </button>
    </div>
  </div>

  <div class="overlay hidden" id="gameover">
    <div class="card gameover-card">
      <div id="finalStats" class="score">0 m</div>
      <button class="btn big" id="againBtn">Restart</button>
    </div>
  </div>

  <script>
  (() => {
    // Canvas setup with HiDPI scaling
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    function resize() {
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.floor(window.innerWidth);
      const h = Math.floor(window.innerHeight);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing to CSS pixels
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Game state
    const STATE = { Menu: 'menu', Playing: 'playing', GameOver: 'gameover' };
    let state = STATE.Playing; // start immediately

    // UI
    const altitudeEl = document.getElementById('altitude');
        const againBtn = document.getElementById('againBtn');
    const restartBtn = document.getElementById('restartBtn');
    const gameoverOverlay = document.getElementById('gameover');
    const finalStats = document.getElementById('finalStats');
    const setBalloonBtn = document.getElementById('setBalloonBtn');
    const setMinesBtn = document.getElementById('setMinesBtn');
    const balloonInput = document.getElementById('balloonInput');
    const minesInput = document.getElementById('minesInput');
    const soundBtn = document.getElementById('soundBtn');

    // Controls: shield cursor
    const pointer = { x: window.innerWidth * 0.5, y: window.innerHeight * 0.7, active: false };
    const shield = { r: 26, color: 'rgba(255,255,255,0.9)' };

    // Audio system: background music and hit SFX (no external files, uses Web Audio API)
    const audio = {
      ctx: null,
      master: null,
      bg: { gain: null, oscs: [], lfo: null, lfoGain: null, filter: null, started: false },
      muted: true,
      started: false,
    };

    // Background music file (replaces synthesized tones)
    const BG_AUDIO_URL = '7af603853038493.mp3';
    const bgAudio = new Audio(BG_AUDIO_URL);
    bgAudio.loop = true;
    bgAudio.volume = 0.6;

    function initAudio() {
      if (audio.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      audio.ctx = new Ctx();
      audio.master = audio.ctx.createGain();
      audio.master.gain.value = 1.0;
      audio.master.connect(audio.ctx.destination);
    }

    function resumeAudio() {
      if (!audio.ctx) initAudio();
      if (!audio.ctx) return;
      if (audio.ctx.state === 'suspended') audio.ctx.resume();
    }

    function startBackgroundMusic() {
      // Use the provided MP3 as background music instead of synthesized tones
      if (audio.bg.started) return;
      try {
        bgAudio.currentTime = 0;
        bgAudio.muted = audio.muted;
        // Ensure play is triggered from a user gesture elsewhere
        const p = bgAudio.play();
        if (p && typeof p.catch === 'function') p.catch(() => {});
        audio.bg.started = true;
      } catch (_) {
        // ignore autoplay errors; will start on next gesture
      }
    }

    function stopBackgroundMusic() {
      if (!audio.bg.started) return;
      try { bgAudio.pause(); } catch {}
      audio.bg.started = false;
    }

    function playHitSound(intensity = 1) {
      if (!audio.ctx) return;
      resumeAudio();
      const ctx = audio.ctx;
      const o = ctx.createOscillator();
      o.type = 'triangle';
      const base = 420 + Math.random() * 260;
      o.frequency.value = base;
      const g = ctx.createGain();
      const v = Math.min(0.2, 0.06 + intensity * 0.08);
      const now = ctx.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(v, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
      o.frequency.exponentialRampToValueAtTime(base * 0.5, now + 0.18);
      o.connect(g);
      g.connect(audio.master);
      o.start(now);
      o.stop(now + 0.22);
    }

    function updateSoundButton() {
      if (!soundBtn) return;
      if (audio.muted) {
        soundBtn.title = 'Sound: Off';
        soundBtn.innerHTML = `
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M3 9v6h4l5 4V5L7 9H3z"></path>
          <line x1="19" y1="9" x2="23" y2="13"></line>
          <line x1="23" y1="9" x2="19" y2="13"></line>
        </svg>`;
      } else {
        soundBtn.title = 'Sound: On';
        soundBtn.innerHTML = `
        <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <path d="M3 9v6h4l5 4V5L7 9H3z"></path>
          <path d="M16 8a5 5 0 0 1 0 8"></path>
          <path d="M19 5a9 9 0 0 1 0 14"></path>
        </svg>`;
      }
    }

    function setMuted(m) {
      if (!audio.ctx) initAudio();
      if (!audio.ctx) return;
      audio.muted = m;
      const target = m ? 0.0001 : 1.0;
      const now = audio.ctx.currentTime;
      audio.master.gain.cancelScheduledValues(now);
      audio.master.gain.setTargetAtTime(target, now, 0.05);
      // Also mute/unmute the HTMLAudio element
      try { bgAudio.muted = m; } catch {}
      if (!audio.bg.started && !m) startBackgroundMusic();
      updateSoundButton();
    }

    function toggleSound() { setMuted(!audio.muted); }

    function enableSoundFromGesture() {
      if (audio.started) return;
      initAudio();
      resumeAudio();
      startBackgroundMusic();
      audio.muted = false;
      audio.started = true;
      updateSoundButton();
    }

    function setPointerFromEvent(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      pointer.x = Math.max(0, Math.min(rect.width, clientX - rect.left));
      pointer.y = Math.max(0, Math.min(rect.height, clientY - rect.top));
      pointer.active = true;
    }
    window.addEventListener('mousemove', setPointerFromEvent, { passive: true });
    window.addEventListener('touchstart', (e) => { e.preventDefault(); setPointerFromEvent(e); }, { passive: false });
    window.addEventListener('touchmove', (e) => { e.preventDefault(); setPointerFromEvent(e); }, { passive: false });
    window.addEventListener('touchend', () => { pointer.active = false; }, { passive: true });

    // Balloon with optional photo
    const balloon = {
      x: () => canvas.width / DPR * 0.5,
      y: () => canvas.height / DPR * 0.75,
      r: () => Math.min(canvas.width / DPR, canvas.height / DPR) * 0.09,
      wobbleT: 0,
      img: null,
      imgReady: false,
    };

    function loadBalloonFromDataURL(dataURL) {
      if (!dataURL) return;
      const img = new Image();
      img.onload = () => {
        balloon.img = img;
        balloon.imgReady = true;
      };
      img.src = dataURL;
    }

    const PHOTO_A = '5265183082728329370.jpg';
    const PHOTO_B = '5265183082728329372.jpg';
    function loadBalloonFromURL(url) {
      if (!url) return;
      const img = new Image();
      img.onload = () => {
        balloon.img = img;
        balloon.imgReady = true;
      };
      img.src = url;
    }

    function loadImageFromFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const dataURL = reader.result;
        try { localStorage.setItem('balloonPhoto', dataURL); } catch {}
        loadBalloonFromDataURL(dataURL);
      };
      reader.readAsDataURL(file);
    }

    let currentMineImg = null;
    // Single mine image per session to avoid mixing
    function loadMineImageFromURL(url) {
      if (!url) return;
      const img = new Image();
      img.onload = () => { currentMineImg = img; };
      img.src = url;
    }

        function loadMineImageFromFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        const dataURL = reader.result;
        const img = new Image();
        img.onload = () => {
          currentMineImg = img;
          // Ensure no mixing within a session: update existing mines too
          for (const m of mines) { m.img = currentMineImg; }
        };
        img.src = dataURL;
      };
      reader.readAsDataURL(file);
    }

    let sessionIndex = 0;
    function setSessionImages() {
      const balloonURL = (sessionIndex % 2 === 0) ? PHOTO_A : PHOTO_B;
      const mineURL = (sessionIndex % 2 === 0) ? PHOTO_B : PHOTO_A;
      loadBalloonFromURL(balloonURL);
      loadMineImageFromURL(mineURL);
    }

    // HUD photo pickers
    setBalloonBtn && setBalloonBtn.addEventListener('click', () => balloonInput && balloonInput.click());
    setMinesBtn && setMinesBtn.addEventListener('click', () => minesInput && minesInput.click());
    balloonInput && balloonInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      loadImageFromFile(file);
    });
    minesInput && minesInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      loadMineImageFromFile(file);
    });

    // Initialize sound button UI and handlers
    updateSoundButton();
    soundBtn && soundBtn.addEventListener('click', (e) => {
      e.preventDefault();
      if (!audio.started) {
        enableSoundFromGesture();
      } else {
        toggleSound();
      }
    });
    // Auto-enable background on first user interaction (required by mobile autoplay policies)
    ['pointerdown','touchstart','keydown'].forEach(ev => {
      window.addEventListener(ev, enableSoundFromGesture, { once: true, passive: true });
    });

    // Clouds background layers
    const clouds = [];
    const cloudLayers = 3; // parallax layers

    function spawnCloud(layer) {
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;
      const baseSize = [38, 64, 94][layer];
      const size = baseSize + Math.random() * baseSize;
      const y = Math.random() * h * 0.9;
      const dir = Math.random() < 0.5 ? -1 : 1;
      const speed = (0.05 + Math.random() * 0.18) * (layer + 1) * dir;
      const x = dir < 0 ? w + size : -size;
      const alpha = [0.25, 0.35, 0.5][layer];
      const puffCount = 4 + Math.floor(Math.random() * 4);
      const puffs = Array.from({ length: puffCount }, () => ({
        ox: (Math.random() * 0.9 + 0.05) * size,
        oy: (Math.random() * 0.5 - 0.25) * size,
        r: (Math.random() * 0.6 + 0.5) * size * 0.45,
      }));
      clouds.push({ x, y, size, speed, alpha, layer, puffs });
    }

    function ensureClouds() {
      const target = 10; // total across layers
      while (clouds.length < target) {
        const layer = Math.floor(Math.random() * cloudLayers);
        spawnCloud(layer);
      }
    }

    // LTN mines
    const mines = [];
    let spawnTimer = 0;

    function spawnMine() {
      const w = canvas.width / DPR;
      const r = 18 + Math.random() * 12; // slightly bigger mines
      const x = r + Math.random() * (w - 2 * r);
      const y = -r - Math.random() * 60; // from slightly above the top
      const vy = 0.9 + Math.random() * 1.6; // fall speed
      const vx = (Math.random() - 0.5) * 0.6; // small drift
      const spin = (Math.random() * 2 - 1) * 0.02;
      const img = currentMineImg;
      mines.push({ x, y, r, vx, vy, ax: 0, ay: 0, angle: Math.random() * Math.PI * 2, spin, img, hitCooldown: 0 });
    }

    function resetGame() {
      mines.length = 0;
      clouds.length = 0;
      ensureClouds();
      spawnTimer = 0;
      elapsed = 0;
      altitude = 0;
    }

    // Progress
    let elapsed = 0; // seconds
    let altitude = 0; // meters

    // Game loop
    let lastT = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - lastT) / 1000); // clamp to ~30 fps max step
      lastT = now;
      if (state === STATE.Playing) update(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt) {
      elapsed += dt;
      altitude += 2.0 * dt * 10; // 20 m per second for feel

      // Difficulty scaling
      const difficulty = Math.min(1.8, 1 + elapsed * 0.05); // slowly increase spawn rate & speed

      // Spawn mines
      spawnTimer -= dt;
      if (spawnTimer <= 0) {
        spawnMine();
        spawnTimer = Math.max(0.25, 0.9 - elapsed * 0.02); // faster over time
      }

      // Update mines
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;

      for (let i = mines.length - 1; i >= 0; i--) {
        const m = mines[i];
        if (m.hitCooldown > 0) m.hitCooldown -= dt;
        // Gravity-like fall + slight acceleration to simulate the balloon rising
        m.vy += 0.02 * dt * 60 * difficulty * 0.2; // subtle

        // Shield interaction (repulsion)
        const dx = m.x - pointer.x;
        const dy = m.y - pointer.y;
        const dist = Math.hypot(dx, dy);
        const minDist = m.r + shield.r;
        if (dist < minDist) {
          const nx = dist > 0 ? dx / dist : 1;
          const ny = dist > 0 ? dy / dist : 0;
          const overlap = (minDist - dist);
          if (!m.hitCooldown || m.hitCooldown <= 0) {
            const intensity = Math.max(0.05, Math.min(1, overlap / minDist));
            try { playHitSound(intensity); } catch (_) {}
            m.hitCooldown = 0.14;
          }
          // push out of the shield
          m.x += nx * overlap * 0.8;
          m.y += ny * overlap * 0.8;
          // add velocity away to "deflect"
          const push = 2.0 + Math.min(3.5, 0.02 * elapsed);
          m.vx += nx * push;
          m.vy += ny * push;
        }

        // Update position
        m.x += m.vx * dt * 60;
        m.y += m.vy * dt * 60;
        m.angle += m.spin * dt * 60;

        // Wall bounce on sides for variety
        if (m.x < m.r) { m.x = m.r; m.vx *= -0.6; }
        if (m.x > w - m.r) { m.x = w - m.r; m.vx *= -0.6; }

        // Remove if far below screen
        if (m.y - m.r > h + 120) {
          mines.splice(i, 1);
        }
      }

      // Balloon wobble
      balloon.wobbleT += dt;

      // Collision: mine with balloon
      const bx = balloon.x() + Math.sin(balloon.wobbleT * 1.6) * balloon.r() * 0.08;
      const by = balloon.y() + Math.cos(balloon.wobbleT * 1.1) * balloon.r() * 0.06;
      const br = balloon.r();
      for (let i = 0; i < mines.length; i++) {
        const m = mines[i];
        const dx = m.x - bx;
        const dy = m.y - by;
        const d = Math.hypot(dx, dy);
        if (d < (m.r + br * 0.85)) { // a bit generous to balloon
          // Game over
          state = STATE.GameOver;
          gameoverOverlay.classList.remove('hidden');
          finalStats.textContent = `${Math.floor(altitude)} m`;
          break;
        }
      }

      // HUD
      altitudeEl.textContent = `word: ${Math.floor(altitude)} m`;
      
      // Clouds update
      for (let i = clouds.length - 1; i >= 0; i--) {
        const c = clouds[i];
        c.x += c.speed * dt * 60;
        if (c.speed < 0 && c.x < -c.size * 2) clouds.splice(i, 1);
        if (c.speed > 0 && c.x > (w + c.size * 2)) clouds.splice(i, 1);
      }
      ensureClouds();
    }

    function render() {
      const w = canvas.width / DPR;
      const h = canvas.height / DPR;

      // Sky gradient background (matches CSS but dynamic per-frame if desired)
      const grad = ctx.createLinearGradient(0, 0, 0, h);
      grad.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--sky-top'));
      grad.addColorStop(0.6, getComputedStyle(document.documentElement).getPropertyValue('--sky-mid'));
      grad.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue('--sky-bot'));
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);

      // Clouds
      for (let layer = 0; layer < cloudLayers; layer++) {
        ctx.save();
        for (const c of clouds) {
          if (c.layer !== layer) continue;
          ctx.globalAlpha = c.alpha;
          ctx.fillStyle = '#fff';
          // Draw simple puffed cloud
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.size * 0.35, 0, Math.PI * 2);
          for (const p of c.puffs) {
            ctx.moveTo(c.x + p.ox + p.r, c.y + p.oy);
            ctx.arc(c.x + p.ox, c.y + p.oy, p.r, 0, Math.PI * 2);
          }
          ctx.fill();
        }
        ctx.restore();
      }

      // Mines
      for (const m of mines) {
        drawMine(m);
      }

      // Balloon
      drawBalloon();

      // Shield cursor on top
      drawShield();
    }

    function drawShield() {
      const g = ctx.createRadialGradient(pointer.x, pointer.y, 2, pointer.x, pointer.y, shield.r);
      g.addColorStop(0, 'rgba(255,255,255,0.95)');
      g.addColorStop(1, 'rgba(255,255,255,0.6)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(pointer.x, pointer.y, shield.r, 0, Math.PI * 2);
      ctx.fill();

      // Subtle outline
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    function drawBalloon() {
      const x = balloon.x() + Math.sin(balloon.wobbleT * 1.6) * balloon.r() * 0.08;
      const y = balloon.y() + Math.cos(balloon.wobbleT * 1.1) * balloon.r() * 0.06;
      const r = balloon.r();

      // String
      ctx.strokeStyle = 'rgba(120,90,60,0.8)';
      ctx.lineWidth = Math.max(1.2, r * 0.03);
      ctx.beginPath();
      ctx.moveTo(x, y + r * 0.95);
      ctx.bezierCurveTo(x - r * 0.2, y + r * 1.3, x + r * 0.25, y + r * 1.8, x, y + r * 2.2);
      ctx.stroke();

      // Balloon body
      const grad = ctx.createLinearGradient(x - r, y - r, x + r, y + r);
      grad.addColorStop(0, '#ff5a4f');
      grad.addColorStop(0.5, '#ff2f2f');
      grad.addColorStop(1, '#d31919');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(x, y, r * 0.95, r * 1.1, 0, 0, Math.PI * 2);
      ctx.fill();

      // Photo window (clip circle)
      const innerR = r * 0.65;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, innerR, 0, Math.PI * 2);
      ctx.clip();
      if (balloon.imgReady && balloon.img) {
        // cover the circle with the image maintaining aspect
        const img = balloon.img;
        const aspect = img.width / img.height;
        const targetSize = innerR * 2;
        let drawW, drawH;
        if (aspect > 1) { // wider
          drawH = targetSize;
          drawW = targetSize * aspect;
        } else {
          drawW = targetSize;
          drawH = targetSize / aspect;
        }
        ctx.drawImage(img, x - drawW / 2, y - drawH / 2, drawW, drawH);
      } else {
        // Default pattern if no photo
        const g = ctx.createLinearGradient(x - innerR, y - innerR, x + innerR, y + innerR);
        g.addColorStop(0, '#fff3');
        g.addColorStop(1, '#0001');
        ctx.fillStyle = g;
        ctx.fillRect(x - innerR, y - innerR, innerR * 2, innerR * 2);
      }
      ctx.restore();

      // Knot
      ctx.fillStyle = '#9b0e0e';
      ctx.beginPath();
      ctx.moveTo(x - r * 0.08, y + r * 1.0);
      ctx.lineTo(x + r * 0.08, y + r * 1.0);
      ctx.lineTo(x, y + r * 1.2);
      ctx.closePath();
      ctx.fill();

      // Highlight
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(x - r * 0.35, y - r * 0.45, r * 0.18, r * 0.35, -0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    function drawMine(m) {
      const { x, y, r, angle } = m;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Body
      const bodyR = r * 0.78;
      const grad = ctx.createRadialGradient(0, 0, bodyR * 0.2, 0, 0, bodyR);
      grad.addColorStop(0, '#5b6673');
      grad.addColorStop(1, '#2c3440');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(0, 0, bodyR, 0, Math.PI * 2);
      ctx.fill();

      // Spikes
      ctx.strokeStyle = '#2b313a';
      ctx.fillStyle = '#3a4350';
      ctx.lineWidth = Math.max(1.2, r * 0.08);
      const spikes = 8;
      for (let i = 0; i < spikes; i++) {
        const a = (i / spikes) * Math.PI * 2;
        const sx = Math.cos(a);
        const sy = Math.sin(a);
        const inner = bodyR * 0.85;
        const outer = r * 1.08;
        ctx.beginPath();
        ctx.moveTo(sx * inner, sy * inner);
        ctx.lineTo(sx * outer, sy * outer);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(sx * outer, sy * outer, r * 0.08, 0, Math.PI * 2);
        ctx.fill();
      }

      // Center photo if available
      if (m.img) {
        const photoR = bodyR * 0.75;
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, photoR, 0, Math.PI * 2);
        ctx.clip();
        const img = m.img;
        const aspect = img.width / img.height;
        const target = photoR * 2;
        let drawW, drawH;
        if (aspect > 1) { drawH = target; drawW = target * aspect; } else { drawW = target; drawH = target / aspect; }
        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        ctx.restore();
      } else {
        // Studs only when no photo to avoid covering the image
        ctx.fillStyle = '#8c96a6';
        for (let i = 0; i < 5; i++) {
          const a = i * (Math.PI * 2 / 5) + 0.3;
          ctx.beginPath();
          ctx.arc(Math.cos(a) * bodyR * 0.55, Math.sin(a) * bodyR * 0.55, r * 0.09, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    // UI wiring
    function startGame() {
      setSessionImages();
      resetGame();
      state = STATE.Playing;
      gameoverOverlay.classList.add('hidden');
      sessionIndex = (sessionIndex + 1) % 2;
    }

    againBtn && againBtn.addEventListener('click', startGame);
    restartBtn && restartBtn.addEventListener('click', startGame);

    // Start game; images alternate each restart
    startGame();
  })();
  </script>
</body>
</html>